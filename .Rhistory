install.packages("ggplot2")
install.packages("stringr")
?clear
?clr
rnorm
filehash
?filehash
clear
library(ggplot)
library(ggplot2)
rbinom
z <- 5
while(z >= 3 && z <= 10) {
print(z)
coin <- rbinom(1, 1, 0.5)
if(coin == 1) {
z <- z + 1
} else {
z <- z - 1
}
}
install.packages("KernSmooth")
packageDescription('KernSmooth')
citation('KernSmooth')
library(KernSmooth)
makeVector <- function(x = numeric()) {
m <- NULL
set <- function(y) {
x <<- y
m <<- NULL
}
get <- function() x
setmean <- function(mean) m <<- mean
getmean <- function() m
list(set = set, get = get,
setmean = setmean,
getmean = getmean)
}
makeVector(c(1:100))
makeVector(1:10)
cachemean <- function(x, ...) {
m <- x$getmean()
if(!is.null(m)) {
message("getting cached data")
return(m)
}
data <- x$get()
m <- mean(data, ...)
x$setmean(m)
m
}
x <- makeVector(c(1:100))
x$egt
x$get
x$get()
cachemean(x)
cashmean(x)
cachemean(x)
makeVector <- function(x = numeric()) {
m <- NULL
set <- function(y) {
x <<- y
m <<- NULL
}
get <- function() x
setmean <- function(mean) m <<- mean
getmean <- function() m
list(set = set, get = get,
setmean = setmean,
getmean = getmean)
}
cachemean <- function(x, ...) {
m <- x$getmean()
if(!is.null(m)) {
message("getting cached data")
return(m)
}
data <- x$get()
m <- mean(data, ...)
x$setmean(m)
m
}
x <- makeVector()
x$set(c(1,2,3,4,5,6,7,8))
x$get()
cashemean(x)
cachemean(x)
cachemean(x)
m
x$m
?numeric()
?matrix()
x <- matrix()
View(x)
makeCacheMatrix <- function(x = matrix()) {
m <- NULL
set <- function(y) {
x <<- y
m <<- NULL
}
get <- function() x
setinv <- function(inv) m <<- inv
getinv <- function() m
list(set = set, get = get,
setinv = setinv,
getinv = getinv)
}m
?setmean()
?list()
makeCacheMatrix <- function(x = numeric()) {
m <- NULL
set <- function(y) {
x <<- y
m <<- NULL
}
get <- function() x
setinv <- function(inv) m <<- inv
getinv <- function() m
list(set = set, get = get,
setinv = setinv,
getinv = getinv)
}m
makeCacheMatrix <- function(x = numeric()) {
m <- NULL
set <- function(y) {
x <<- y
m <<- NULL
}
get <- function() x
setinv <- function(inv) m <<- inv
getinv <- function() m
}m
makeCacheMatrix <- function(x = numeric()) {
m <- NULL
set <- function(y) {
x <<- y
m <<- NULL
}
get <- function() x
setinv <- function(inv) m <<- inv
getinv <- function() m
}m
makeCacheMatrix <- function(x = numeric()) {
m <- NULL
set <- function(y) {
x <<- y
m <<- NULL
}
get <- function() x
setsolve <- function(solve) m <<- solve
getsolve <- function() m
list(set = set, get = get,
setsolve = setsolve,
getsolve = getsolve)
}m
list(set = set, get = get,
setmean = setmean,
getmean = getmean)
list()
?list()
matrix(c(-1,-2,1,1), 2, 2)
m <- matrix(c(-1,-2,1,1), 2, 2)
solve(m)
setsolve <- function(solve) m <<- solve
setsolve(m)
setsolve <- solve(m)
setsolve <- function(solve) m <<- solve
a <- setsolve(m)
View(a)
View(a)
View(m)
View(m)
setmean <- function(mean)
m <<- mean
setmean(m)
a <- setmean(m)
a <- c(1,2,3,6,58,99,79,200)
setmean(a)
makeCacheMatrix <- function(x = matrix()) {
m <- NULL
set <- function(y) {
x <<- y
m <<- NULL
}
get <- function() x
setsolve <- function(solve) m <<- solve
getsolve <- function() m
}m
library(datasets)
data(iris)
?iris
mean(iris$Sepal.Length)
colMeans(iris)
apply(iris, 1, mean)
apply(iris[, 1:4], 2, mean)
library(datasets)
data(mtcars)
?mtcars
tapply(mtcars$cyl, mtcars$mpg, mean)
a <- array(rnorm(2*2*10), c(2,2,10))
apply(a, c(1,2,3), mean)
rm(a)
split(mtcars, mtcars$cyl)
tapply(mtcars$cyl, mtcars$mpg, mean)
a = mean(subset(mtcars, cyl == 4) [hp, ])
a = mean(subset(mtcars, cyl == 4) ["hp", ])
a = mean(subset(mtcars, cyl == 4) [hp, ], na.rm = T)
a = mean(subset(mtcars, cyl == 4) ["hp", ], na.rm = T)
subset(mtcars, cyl == 4) ["hp", ]
subset(mtcars, cyl == 4) [ , "hp"]
a = mean(subset(mtcars, cyl == 4) [, "hp"], na.rm = T)
b = mean(subset(mtcars, cyl == 8) [, "hp"], na.rm = T)
abs(a - b)
debug(ls)
ls
ls
end
undebug(ls)
q
undebug(ls)
debugonce()
ls
library(datasets)
data(mtcars)
with(mtcars, tapply(mpg, cyl, mean))
?with()
library(datasets)
data(iris)
?iris
head(iris)
mean(iris$Sepal.Length(specise == virginica))
mean(iris$Sepal.Length, specise == virginica)
View(iris)
mean(subset(iris, Species == virginica) [, "Sepal.Length"])
mean(subset(iris, Species == "virginica") [, "Sepal.Length"])
pwd
# makeCacheMatrix creates a list containing a function to
# 1. set the value of the matrix
# 2. get the value of the matrix
# 3. set the value of inverse of the matrix
# 4. get the value of inverse of the matrix
makeCacheMatrix <- function(x = matrix()) {
inv <- NULL
set <- function(y) {
x <<- y
inv <<- NULL
}
get <- function() x
setinverse <- function(inverse) inv <<- inverse
getinverse <- function() inv
list(set=set, get=get, setinverse=setinverse, getinverse=getinverse)
}
# The following function returns the inverse of the matrix. It first checks if
# the inverse has already been computed. If so, it gets the result and skips the
# computation. If not, it computes the inverse, sets the value in the cache via
# setinverse function.
# This function assumes that the matrix is always invertible.
cacheSolve <- function(x, ...) {
inv <- x$getinverse()
if(!is.null(inv)) {
message("getting cached data.")
return(inv)
}
data <- x$get()
inv <- solve(data)
x$setinverse(inv)
inv
}
# makeCacheMatrix creates a list containing a function to
# 1. set the value of the matrix
# 2. get the value of the matrix
# 3. set the value of inverse of the matrix
# 4. get the value of inverse of the matrix
makeCacheMatrix <- function(x = matrix()) {
inv <- NULL
set <- function(y) {
x <<- y
inv <<- NULL
}
get <- function() x
setinverse <- function(inverse) inv <<- inverse
getinverse <- function() inv
list(set=set, get=get, setinverse=setinverse, getinverse=getinverse)
}
amatrix = makeCacheMatrix(matrix(c(1,2,3,4), nrow=2, ncol=2))
amatrix$get()
cacheSolve(amatrix)
amatrix$getinverse()
cacheSolve(amatrix)
amatrix$set(matrix(c(0,5,99,66), nrow=2, ncol=2))
cacheSolve(amatrix)
amatrix$get()
amatrix$getinverse()
makeCacheMatrix <- function(x = matrix()) {
inv <- NULL
set <- function(y) {
x <<- y
inv <<- NULL
}
get <- function() x
setinv<- function(invm = matrix()) inv <<- invm
getinv <- function() inv
list(set = set, get = get,
setinv = setinv,
getinv = getinv)
}
makeCacheMatrix <- function(x = matrix()) {
inv <- NULL
set <- function(y) {
x <<- y
inv <<- NULL
}
get <- function() x
setinv<- function(invm = matrix()) inv <<- invm
getinv <- function() inv
list(set = set, get = get,
setinv = setinv,
getinv = getinv)
}
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
inv <- x$getinv()
if(!is.null(inv)) {
message("getting cached data")
return(inv)
}
data <- x$get()
inv <- solve(data, ...)
x$setinv(inv)
inv
}
m <- matrix(c(-1, -2, 1, 1), 2,2)
x <- makeCacheMatrix(m)
m <- matrix(c(-1, -2, 1, 1), 2,2)
x <- makeCacheMatrix(m)
x$get()
inv <- cacheSolve(x)
inv
> inv <- cacheSolve(x)
getting cached data
> inv
inv <- cacheSolve(x)
inv <- cacheSolve(x)
inv
}
makeCacheMatrix <- function(x = matrix()) {
# inverse set to NULL by default
i <- NULL
# function to set x
set <- function(y){
x <<- y
i <<- NULL
}
# function to get x
get <- function() x
# function to set inverse
setinverse <- function(inverse = matrix()) i <<- inverse
# function to get inverse
getinverse <- function() i
# return a list
list(set=set, get=get,setinverse=setinverse, getinverse=getinverse)
}
}
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
i <- x$getinverse()
if(!is.null(i)){
message("getting chcaed inverse")
return(i)
}
data <- x$get()
i <- solve(data,...)
x$setinverse(i)
i
}
m <- matrix(c(-1, -2, 1, 1), 2,2)
x <- makeCacheMatrix(m)
x$get()
m <- matrix(c(-1, -2, 1, 1), 2,2)
x <- makeCacheMatrix(m)
x$get()
inv <- cacheSolve(x)
inv
inv <- cacheSolve(x)
inv
makeCacheMatrix <- function(x = matrix()){
m <- NULL
set <- function(y) {
x <<- y
m <<- NULL
}
get <- function() x
setinverse <- function(solve) m <<- solve
getinverse <- function() m
list(set = set, get = get,
setinverse = setinverse,
getinverse = getinverse)
}
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
m <- x$getinverse()
if(!is.null(m)) {
message("getting cached data")
return(m)
}
## If not found the inverse in the cache, then computes it and save in the cache
data <- x$get()
m <- solve(data)
x$setinverse(m)
m
}
m <- matrix(c(-1, -2, 1, 1), 2,2)
x <- makeCacheMatrix(m)
x$get()
m <- matrix(c(-1, -2, 1, 1), 2,2)
x <- makeCacheMatrix(m)
x$get()
m <- matrix(c(-1, -2, 1, 1), 2,2)
x <- makeCacheMatrix(m)
x$get()
inv <- cacheSolve(x)
inv
inv <- cacheSolve(x)
inv
makeCacheMatrix <- function(x = matrix()) {
i <- NULL
set <- function(y){
x <<- y
i <<- NULL
}
get <- function() x
setinv <- function(inv) i <<- inv
getinv <- function() i
list(set=set,
get=get,
getinv=getinv,
setinv=setinv)
}
makeCacheMatrix <- function(x = matrix()) {
i <- NULL
set <- function(y){
x <<- y
i <<- NULL
}
get <- function() x
setinv <- function(inv) i <<- inv
getinv <- function() i
list(set=set,
get=get,
getinv=getinv,
setinv=setinv)
}
}
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
i <- x$getinv()
if(!is.null(i)) {
message("getting cached data")
return(i)
}
data <- x$get()
i <- solve(data)
x$setinv(i)
i
}
m <- matrix(c(-1, -2, 1, 1), 2,2)
x <- makeCacheMatrix(m)
x$get()
m <- matrix(c(-1, -2, 1, 1), 2,2)
x <- makeCacheMatrix(m)
x$get()
inv <- cacheSolve(x)
inv
inv <- cacheSolve(x)
inv
mv ~/.rstudio-desktop ~/rstudio-desktop.old
setwd("~/github/ExData_Plotting1")
